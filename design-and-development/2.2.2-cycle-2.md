# 2.2.2 Cycle 2 - Adding physics

## Overview

In this cycle, I will use a library called `cannon-es` to add physics simulation to the game. I will integrate the physics simulation into my game using ThreeJS to render the position of the cannon-es objects in the scene.

In order to test the physics simulation, I will generate a sloped plane and a ball. I will then add gravity to the simulation so that the ball rolls down the plane. I will also include features developed in the last cycle such as the lighting and the 3D rendering using ThreeJS.

To help with visualisation and debugging, I will add orbit controls to the camera so that I will be able to look around and orbit the camera using mouse controls. Similarly, so that I do not have to constantly reset the simulation, if the sphere's height drops below a certain point I will reset it to above the platform.

### Objectives

* [x] Render an inclined plane with a ball on top
* [x] Add cannon-es to simulate phsyics
* [x] Add gravity to the world so that the ball falls
* [x] Add collision detection so that the ball rolls down the plane
* [x] Add orbit controls to the camera
* [x] Teleport the sphere to above the platform if it falls too far

### Key Variables

| Variable Name   | Use                                                                             |   |
| --------------- | ------------------------------------------------------------------------------- | - |
| gravity         | This variable controls the speed at which downwards acceleration occurs.        |   |
| controls        | This variable initiates the ThreeJS orbit controls.                             |   |
| world           | This variable represents the world that the simulated physics takes place in.   |   |
| sphereBody      | Stores information about the sphere's cannon-es physics body.                   |   |
| sphereMesh      | Stores information about the sphere's shape and size.                           |   |
| groundBody      | Stores information about the ground's cannon-es physics body.                   |   |
| planeMesh       | Stores information about the plane that represents the ground's shape and size. |   |
| contactMaterial | Stores information about the contact physics between the sphere and the ground. |   |

### Pseudocode

```
gravity := 9.82
scene := new ThreeJSScene()
camera := new ThreeJSCamera(cameraSettings)
renderer := new ThreeJSRenderer(rendererSettings)
controls := new ThreeJSOrbitControls(orbitControlsSettings)

world := new CannonWorld({gravity: gravity}) 

ambientLight := new AmbientLight(ambientLightSettings)
directionalLight := new DirectionalLight(directionalLightSettings)
camera.position = Vector(5, 5, 5)

// Create a simulated sphere
sphereMaterial := new CannonMaterial()
sphereBody := new CannonBody({
    mass: 1,
    material: sphereMaterial,
    position: Vector(0, 5, 0)
})
sphereBody.addShape(new CannonSphere())
// Create a rendered sphere
sphereMesh := new SphereMesh(sphereSettings)
sphereMesh.position = Vector(0, 5, -2)

// Create the simulated ground
groundMaterial := new CannonGroundMaterial()
groundBody := new CannonBody({
    mass: 0,
    material: groundMaterial
})
groundBody.addShape(new CannonPlane())
groundBody.setEulerRotation(-Math.PI / 4, 0, 0) // Rotate the simulated plane
// Create the rendered plane
planeMesh := new PlaneMesh(planeSettings)
planeMesh.position = groundBody.position
planeMesh.rotation = groundBody.rotation

// Describe how sphere interacts with the plane
contactMaterial := new CannonContactMaterial(
    groundMaterial,
    sphereMaterial,
    materialSettings
)

// Add all rendered objects to the scene
scene.add(sphereMesh)
scene.add(ambientLight)
scene.add(directionalLight)
scene.add(planeMesh)
// Add all simulated bodies to the simulated world
world.addBody(sphereBody)
world.addBody(groundBody)
world.addContactMaterial(contactMaterial)

function animate():
    // Move the world forward 1 frame
    world.tick()

    // If the sphere is too far below the platform, teleport it above
    if sphereBody.position.y < -50 then:
        sphereBody.position = Vector(0, 5, -2)
        sphereBody.velocity = Vector(0, 0, 0)
        sphereBody.angularVelocity = Vector(0, 0, 0)
    end if
        
    // Update the rendered sphere to the simulated sphere's position every frame
    sphereMesh.position = sphereBody.position
    sphereMesh.rotation = sphereBody.rotation
    
    requestAnimationFrame(animate)
    renderer.render(scene, camera)
end function
```

## Development

### Outcome

In `/src/index.ts` I modified the ThreeJS cube object by turning it into a sphere. I also created a plane which will be linked to the ground physics object. Next, I created cannon-es physics bodies with 2 different materials - the sphere material and the ground material. These do not render on their own so I have to move the ThreeJS rendered objects to the location of the simulated physics objects every frame.

{% tabs %}
{% tab title="/src/index.ts" %}
```typescript
import "./style.css";
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";
import * as CANNON from "cannon-es";

const gravity = -9.8;

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setClearColor(0x0f0019);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

// Initiate orbit controls
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

const world = new CANNON.World({
  gravity: new CANNON.Vec3(0, gravity, 0),
});

const ambientLighting = new THREE.AmbientLight(0xaaaaaa);
const directionalLighting = new THREE.DirectionalLight(0xffffff);
directionalLighting.position.set(-5, 5, 5);
directionalLighting.castShadow = true;
camera.position.set(5, 5, 5);
camera.lookAt(0, 0, 0);

// Create a simulated sphere
const sphereMaterial = new CANNON.Material();
const sphereBody = new CANNON.Body({
  mass: 1,
  material: sphereMaterial,
  position: new CANNON.Vec3(0, 5, -2),
});
sphereBody.addShape(new CANNON.Sphere(0.5));

// Create a rendered sphere
const sphereMesh = new THREE.Mesh(
  new THREE.SphereGeometry(0.5, 64, 64),
  new THREE.MeshLambertMaterial({
    color: 0xff0044,
  })
);
sphereMesh.castShadow = true;

// Create the simulated ground
const groundMaterial = new CANNON.Material("ground");
const groundBody = new CANNON.Body({ mass: 0, material: groundMaterial });
groundBody.addShape(new CANNON.Box(new CANNON.Vec3(2, 4, 0.1)));
groundBody.quaternion.setFromEuler(-Math.PI / 3, 0, 0);

// Create the rendered plane
const planeMesh = new THREE.Mesh(
  new THREE.PlaneGeometry(4, 8),
  new THREE.MeshLambertMaterial({ color: 0xffffff })
);
planeMesh.quaternion.set(
  groundBody.quaternion.x,
  groundBody.quaternion.y,
  groundBody.quaternion.z,
  groundBody.quaternion.w
);
planeMesh.position.set(
  groundBody.position.x,
  groundBody.position.y + 0.1,
  groundBody.position.z
);
planeMesh.receiveShadow = true;

// Describe how the sphere interacts with the plane
const contactMaterial = new CANNON.ContactMaterial(
  groundMaterial,
  sphereMaterial,
  { friction: 0.9, restitution: 0.5 }
);

// Add all simulated bodies to the simulated world
world.addBody(sphereBody);
world.addBody(groundBody);
world.addContactMaterial(contactMaterial);

// Add all rendered objects to the scene
scene.add(sphereMesh);
scene.add(ambientLighting);
scene.add(directionalLighting);
scene.add(planeMesh);

const clock = new THREE.Clock();

function animate() {
  renderer.render(scene, camera);

  world.step(clock.getDelta());
  
  // If the sphere is too far below the platform, teleport it above
  if (sphereBody.position.y < -50) {
    sphereBody.position = new CANNON.Vec3(0, 5, -2);
    sphereBody.velocity = new CANNON.Vec3(0, 0, 0);
    sphereBody.angularVelocity = new CANNON.Vec3(0, 0, 0);
  }

  // Update the rendered sphere to the simulated sphere's position every frame
  sphereMesh.position.set(
    sphereBody.position.x,
    sphereBody.position.y,
    sphereBody.position.z
  );
  sphereMesh.quaternion.set(
    sphereBody.quaternion.x,
    sphereBody.quaternion.y,
    sphereBody.quaternion.z,
    sphereBody.quaternion.w
  );
  window.requestAnimationFrame(animate);
}
animate();

```
{% endtab %}
{% endtabs %}
