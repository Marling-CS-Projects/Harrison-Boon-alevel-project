# 2.2.3 Cycle 3 - Terrain generation

## Overview

Now that I am able to render and simulate a sphere in 3D, I now need somewhere to put it. In the main world, I plan to have terrain that would be generated using procedural generation. This is a method whereby computers and computational algorithms are used to generate data randomly.

The data will then be used as a heightmap to create the both the rendered and the simulated ground surface. I will use a noise map for the terrain height because it tends to produce smooth, realistic curves that are neither too steep to drive up nor too bland or boring.

The data for my heightmap will be more specifically produced using a '2D Simplex Noise Map' which can be easily generated using packages in TypeScript. This type of procedural generation needs a 'seed' string for the generation to be based upon. This will be a randomly generated string that, when multiplayer functionality is added, can also be used as an invite code for lobbies.

I will also add colouring to the terrain based off of how high each point on the map is. This will help the level to look more realistic and will also ease the strain on the player's eyes as there will be texture available to make the terrain more visible.

### Objectives

* [x] Generate a heightmap using a Simplex noise map
* [x] Generate a ThreeJS plane using the heightmap
* [x] Use the heightmap to generate a Cannon-ES ground object with the same shape as the plane
* [x] Terrain should look neither boring nor too unrealistic
* [ ] Make sure that the new features do not clash with old features
* [x] Graphics should remain low-poly
* [x] Terrain should be coloured based off of height
* [x] Collisions with the ground should be realistic and predicatable

### Key Variables

|   |   |   |
| - | - | - |
|   |   |   |
|   |   |   |
|   |   |   |

### Pseudocode

```
Function generateTerrain(seed):
    simplexMap := new SimplexNoiseMap(seed)
    planeGeometry := new PlaneGeometry(50, 50) // Creates a plane with 50 height segments and 50 width segments
    For i = 0  to planeGeometry.vertices.length:
        // Access the height map's value at the vertex's position
        x := planeGeometry.vertices[i].x
        y := planeGeometry.vertices[i].y
        height := simplexMap(x, y)
        
        //  Set the vertex's height accordingly
        planeGeometry.vertices[i].z = height
        
        // Assign each vertex a colour (ThreeJS can handle how each vertex's colour blends with each other)
        If height > 18:
            planeGeometry.vertices[i].colour = highColour
        Else If height > 5:
            planeGeometry.vertices[i].colour = highMidColour
        Else If height > -15:
            planeGeometry.vertices[i].colour = lowMidColour
        Else:
            planeGeometry.vertices[i].colour = lowColour
        End If
    End For
    
    groundMaterial := new CannonGroundMaterial()
    groundBody := CannonBody({
        mass: 0,
        material: groundMaterial,
    })
    
    For i = 0 to planeGeometry.vertices.length:
        // Find current vertex's position
        x := planeGeometry.vertices[i].x
        y := planeGeometry.vertices[i].y
        z := planeGeometry.vertices[i].z
        
        // Find first adjacent vertex's position
        nextX1 := planeGeometry.vertices[i + 1].x
        nextY1 := planeGeometry.vertices[i + 1].y
        nextZ1 := planeGeometry.vertices[i + 1].z
        
        // Find second adjacent vertex's position
        distanceInArray := planeGeometry.size / planeGeometry.segments
        nextX2 := planeGeometry.vertices[i + distanceInArray].x
        nextY2 := planeGeometry.vertices[i + distanceInArray].y
        nextZ2 := planeGeometry.vertices[i + distanceInArray].z
        
        // Find the first and second adjacent vertices' adjacent vertex's position
        nextX3 := planeGeometry.vertices[i + distanceInArray + 1].x
        nextY3 := planeGeometry.vertices[i + distanceInArray + 1].y
        nextZ3 := planeGeometry.vertices[i + distanceInArray + 1].z
        
        // Create a simulated triangle with the same shape as 3 of the ground vertices
        vertices1 := [
            [x, y, z],
            [nextX1, nextY1, nextZ1],
            [nextX2, nextY2, nextZ2]
        ]
        trimesh1 := new Trimesh(vertices1)
        groundBody.addShape(trimesh1)
        
        // Create a second simualted triangle
        vertices2 := [
            [nextX1, nextY1, nextZ1],
            [nextX2, nextY2, nextZ2],
            [nextX3, nexty3, nextZ3]
        ]
        trimesh2 := new Trimesh(vertices2)
        groundBody.addShape(trimesh2)
    End For
    
    // return both the generated terrain and the simulated ground body
    return (planeGeometry, groundBody)
End Function
```

## Testing

### Tests

### Evidence

![A zoomed out screenshot of the generated terrain](<../.gitbook/assets/image (2).png>)

![A close up screenshot showing the ball interacting with the terrain](<../.gitbook/assets/image (8).png>)
