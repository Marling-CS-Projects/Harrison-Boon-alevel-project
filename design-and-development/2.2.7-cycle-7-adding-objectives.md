# 2.2.7 Cycle 7 - Adding objectives

## Overview

After adding a menu, I decided that I would now have to add objectives to the map, this would be in the form of checkpoints that the player would have to drive through. Eventually, I plan to add a clock that will time how long it takes for the user to collect all of the checkpoints. However, that will come in a later cycle.

### Objectives

* [x] Upon loading, spawn checkpoints in random points on the map
* [x] Checkpoints should be in accessible places
* [x] Checkpoints should disappear after being touched
* [x] The car shouldn't collide with the checkpoints

### Key Variables

| Variable Name     | Use                                                     |   |
| ----------------- | ------------------------------------------------------- | - |
| points            | An array containing all of the active points            |   |
| x, y, z           | Position variables of the randomly selected variable    |   |
| mesh              | Three.JS mesh of the checkpoint (rendered as a sphere)  |   |
| point             | Just one of the points that the detection loops through |   |
| vehicle.x, .y, .z | Holds positional information about the vehicle          |   |

### Pseudocode

{% tabs %}
{% tab title="Spawning Checkpoints" %}
```
Function spawnPoints(number, planeGeometry):
    points := []
    For x in range(number):
        randomNumber := random()
        x := PlaneGeometry.points[random].x
        y := PlaneGeometry.points[random].y
        z := PlaneGeometry.points[random].z
        mesh := new THREE.SphereMesh()
        mesh.position = (x, y, z)
        points.append(mesh)
    End For
    Return points
End Function
```
{% endtab %}

{% tab title="Detecting Collisions" %}
```
Function detectCollision(points, vehicle):
    For i in range(points.length):
            point := points[i]
            If (point.x + 2 > vehicle.x - 5 &&
            point.x - 2 < vehicle.x + 5 &&
            point.y + 2 > vehicle.y - 0.5 &&
            point.y - 2 < vehicle.y + 0.5 &&
            point.z + 2 > vehicle.z - 2 &&
            point.z - 2 < vehicle.z + 2):
                  Return point
          End If
  End For
End Function
```
{% endtab %}
{% endtabs %}

## Development

### Outcome

I decided to have the checkpoints be Three.JS meshes that will be watched for collision. another method I could have used for the generation was using Cannon-ES bodies instead. There were a few issues with this approach: The first issue was that due to poor Cannon documentation I wasn't sure how the `onCollision` listener function worked, this made it hard to work out what it would do. Another issue was that the Cannon method is a lot less performant than the Three.JS mesh method. Given that the collision detection should have to be run every frame, it matters greatly how performant it is.

The function in `/src/spawnPoints.ts` serves the purpose of generating the initial checkpoints in the main map world. It generates a sphere mesh `n` times and adds them each to an array from which they can be accessed. The position of the checkpoints is decided taking a random point on the map's floor (done by generating a random number and accessing co-ordinates for that number)

The function in `/src/detectCollision.ts` runs every frame and compares the position of each sphere to the position of the vehicle. If each object has sufficient overlap the specific checkpoint is the returned from the function as an object.

`/src/detectCollision.ts`'s function is then run in `/src/startGame.ts` and if any checkpoints are returned, they are removed from their storing array and are removed from the Three.JS render world.

{% tabs %}
{% tab title="/src/spawnPoints.ts" %}
```typescript
import * as THREE from "three";
export function spawnPoints(n: number, planeGeometry: THREE.PlaneGeometry) {
  const points: THREE.Mesh[] = [];
  const pointGeometry = new THREE.SphereGeometry(2);
  const pointMaterial = new THREE.MeshLambertMaterial({ color: 0x0022ff });
  const limits = planeGeometry.attributes.position.array.length / 3;
  for (let i = 0; i < n; i++) {
    const random = Math.floor(Math.random() * limits);
    const x = planeGeometry.attributes.position.array[random * 3];
    const y = planeGeometry.attributes.position.array[random * 3 + 2];
    const z = planeGeometry.attributes.position.array[random * 3 + 1];
    const mesh = new THREE.Mesh(pointGeometry, pointMaterial);
    mesh.position.x = x;
    mesh.position.y = y;
    mesh.position.z = -z;
    points.push(mesh);
  }
  return { points };
}
```
{% endtab %}

{% tab title="/src/detectCollision.ts" %}
```typescript
import type * as THREE from "three";
export function detectCollision(points: THREE.Mesh[], vehicleMesh: THREE.Mesh) {
  for (let i = 0; i < points.length; i++) {
    const point = points[i];
    if (
      point.position.x + 2 > vehicleMesh.position.x - 5 &&
      point.position.x - 2 < vehicleMesh.position.x + 5 &&
      point.position.y + 2 > vehicleMesh.position.y - 0.5 &&
      point.position.y - 2 < vehicleMesh.position.y + 0.5 &&
      point.position.z + 2 > vehicleMesh.position.z - 2 &&
      point.position.z - 2 < vehicleMesh.position.z + 2
    ) {
      return point;
    }
  }
}
```
{% endtab %}

{% tab title="/src/startGame.ts" %}
```typescript
...
  const result = detectCollision(points, vehicleMesh);
  if (result) {
    scene.remove(result);
    points.splice(points.indexOf(result), 1);
  }
  if (points.length == 0) {
    // end game
  }
...
```
{% endtab %}
{% endtabs %}

### Challenges

The collision detection algorithm isn't entirely accurate and can sometimes trigger before or after the sphere and the vehicle intersect. This is because the x, y and z offsets in `detectCollision`'s If statement are not taking into account the vehicle's rotation and are instead instating a static collision bounding box around the car. Calculating the collisions further for a more accurate and realistic collision would decrease the performance of the program as well as increasing the complexity from a development standpoint. Besides, with the current algorithm, the slight discrepancies aren't too noticeable.

## Testing

### Tests

| Test | Instructions               | What I expect                                         | What actually happens |
| ---- | -------------------------- | ----------------------------------------------------- | --------------------- |
| 1    | Load the game              | The menu should load                                  | As expected           |
| 2    | Press Start                | The game should load as normal                        | As expected           |
| 3    | -                          | Map should have checkpoints displayed                 | As expected           |
| 4    | Repeat 1-3 a few times     | Checkpoints should appear to have random distribution | As expected           |
| 5    | Drive over the checkpoints | Checkpoints should disappear                          | As expected           |
| 6    | -                          | Make sure nothing broke after updating                | As expected           |

### Evidence

<figure><img src="../.gitbook/assets/image.png" alt=""><figcaption><p>This is the map upon loading</p></figcaption></figure>

<figure><img src="../.gitbook/assets/image (1) (1).png" alt=""><figcaption><p>4 Checkpoints remain after one is driven over</p></figcaption></figure>
